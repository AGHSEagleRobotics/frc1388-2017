// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#define DISTALIGN 4

#include "AutonomousCommand.h"
#include "AutonDrive.h"
#include "AutonTurn.h"
#include <math.h>
#include "Vision.h"
#define THRESHOLD 0.1

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

AutonomousCommand::AutonomousCommand() {
	int choice = 0;
	bool a = !(Robot::driveTrain->firstBit->GetVoltage() > THRESHOLD);
	bool b = !(Robot::driveTrain->secondBit->GetVoltage()> THRESHOLD);
	bool c = !(Robot::driveTrain->thirdBit->GetVoltage() > THRESHOLD);
	bool d = !(Robot::driveTrain->fourthBit->GetVoltage()> THRESHOLD);
	if(a) choice += 8;
	if(b) choice += 4;
	if(c) choice += 2;
	if(d) choice += 1;

	printf("Choice = %i \n", choice);
	printf("If the choice is incorrect, make sure the wires are plugged in the following manner: \n red, blue, orange, green \n");

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
	float horizDist;
	int theta;
	double hypVector;

	switch(choice){

	case 0: /*center pos, set gear*/
		Vision::toggleVisionThread();
		horizDist = Vision::getHorizontalOffset();
		theta = (int) atan(DISTALIGN / horizDist);
		hypVector = sqrt((pow(DISTALIGN, 2)) / (pow(horizDist, 2)));

		AddSequential(new AutonTurn(theta));
		AddSequential(new AutonDrive(hypVector));
		AddSequential(new AutonTurn(-theta));

		while(medianTenSamples() >= 24){
			//need to account for error somehow
			RobotMap::driveTrainRobotDrive->TankDrive(0.5, 0.5);
		}

		AddSequential(new AutonDrive(22));

		break;
	case 1:
		break;
	case 2:
		break;
	}
 }

float AutonomousCommand::medianTenSamples(){

	vector<float> lastTen = Vision::getLastTenSamples();
	float median = 0;
	size_t size = lastTen.size();

	sort(lastTen.begin(), lastTen.end());

	median = (lastTen[4] + lastTen[5]) / 2;

	return median;
}
